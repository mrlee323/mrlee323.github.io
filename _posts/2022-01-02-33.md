---
layout: post
title: "TIL #33 js-training & vue "
data: '2021-01-02'
category: [TIL]

---
## js-training 문제풀이

### for문
```js
//배열 cost의 값을 모두 더하기

let cost = [85, 42, 37, 10, 22, 8, 15];
```
문제풀이
```js
let total_cost = 0;
for(let i = 0; i < cost.length; i++){
  total_cost += cost[i]
}
console.log(total_cost) //219
```
for문
```js
// 우리 유치원은 유아가 20명입니다.  
// 번호가 1번부터 20번까지인 
// 유아들을 “샛별반”, “꽃님반”, “별님반” 에 순서대로 편성해 주세요.
// 즉, 1번유아는 샛별반, 2번유아는 꽃님반,
// 3번유아는 별님반, 4번유아는 다시 샛별반이 되는 순서입니다.

const className= ["샛별반", "꽃님반", "별님반"]
```
문제풀이
```js
const 샛별반 = []
const 꽃님반 = []
const 별님반 = []
const className= [샛별반, 꽃님반, 별님반]
for(let i = 0; i < 20; i++){
    className[i % className.length].push(i+1)
}

console.log(샛별반)//[1, 4, 7, 10, 13, 16, 19]
console.log(꽃님반)//[2, 5, 8, 11, 14, 17, 20]
console.log(별님반)//[3, 6, 9, 12, 15, 18]
```
이 문제는 className이란 배열에 String으로 반명이 있었는데, 각 반의 분배를 하려면 배열로 만들어야 할 것 같아서 각 반의 빈배열로 할당했다. 

지금 문제르 다풀고 보니 코드가 정말 간단한데 처음에 반 3개를 돌리면서 20명을 넣으려고 할때 어떻게 반 3개를 돌리지 라는 고민을 오래했다. for를 중첩으로 사용하면 20번이 아니고 60번을 돌기 때문에 문제에 맞지 않았다. 

세개의 반을 돌릴 방법을 생각하다가 나머지몫이 떠올라 3으로 나누면 나머지는 0, 1, 2만 나올 수 있어 배열의 인덱스를 통해 각 반의 번호를 넣을 수 있었다. 

### for-in 문
```js
// 우리 유치원 아이들은 각자 좋아하는 칭찬스티커가 있습니다. 
// 서로 좋아하는 스티커를 갖고 싸우지 않도록 하기 위해 ‘누가’ 
// ‘어떤’ 스티커를 좋아하는지 기록해 뒀습니다. 
// 오늘 반 아이들에게 칭찬스티커를 주기위해 프린트를 하려고 하는데, 
// 무엇을 몇장 프린트해야 하는지 구해주세요.

  const favSticker = {
    "은지" : "뽀로로",
    "태현" : "티라노사우르스",
    "미림" : "아기상어",
    "미영" : "아기상어",
    "을수" : "뽀로로"
  }
```
문제풀이
```js
const count = {}
for(const child in favSticker){
  if(favSticker[child] in count){
    count[favSticker[child]]++
  } else{
    count[favSticker[child]] = 1
  }
}

console.log(count) //{뽀로로: 2, 티라노사우르스: 1, 아기상어: 2}
```
이 문제에서 favSticker 객체의 값인 스티커명을 다시 키로 받는 객체를 만들었다. 각 키에는 favSticker의 객체를 for-in으로 돌면서 값을 넣어줬다. 처음 1을 넣는 것은 어렵지 않았는데 중복되는 값을 넣어주는데 고민을 많이 했다. 

객체안의 속성을 넣어줄때 속성이 있으면 값에만 1을 추가하고, 아니면 속성을 만들어 값을 1을 할당하는 것이다. 근데 속성안의 속성을 확인하는 방법을 몰랐다. `if(favSticker[child] in count)`이 코드는 간단한데 이렇게 사용하는 걸 몰라서 고민을 오래했다. 처음에는 `count`객체의 속성을 `for문`을 써서 돌아가며 값을 확인하려고 했는데 `if절`이 시작할 때 `count`객체는 빈객체여서 시작이 되지않았다. 객체의 키를 찾는 방법을 구글링하다가 꽤 오랜시간이 걸려서 알아낸게 `includes`가 있었는데 이것보다 더 간단하게 `in`을 사용해서 확인 할수 있었다. 근데 이 `in`은 객체안에서 생성된 프로퍼티 외에 프로토타입에서 생성된 프로퍼티도 객체안 프로퍼티로 같은 취급을 하였다. 이럴때 `hasOwnerProperty`를 사용하면 오직 객체 내에서 생성된 프로퍼티만 찾을 수 있다. 

## vue-js
오늘 강의 내용은 vue에서 composition API에 대한 내용 이었다. composition은 vue 코드내에 로직이 직관적이지 않아 코드가 복잡해 질수록 보기 어려워지는걸 해결해줄 수 있었다. 그방법으로 setup()을 사용하는 것인데 setup()안에서는 반응성이 없어 ref()를 사용해서 반응성을주며 그로인한 객체데이터를 받아오기위해 value를 붙여준다. ref, computed, onMounted 등은 import해서 가져 'vue'에서 가져와야한다. created 메소드는 setup어디에서나 다른 문법적용없이 사용할수 있고 mounted는 onMounted로 불러야한다. setup안에서는 this 사용할수 없는데 이를 대체하기위해 props와 context를 사용하면 된다. 그리고 마지막에는 항상 retrun을 통해서 데이터와 메소드를 내보내줘야한다. 